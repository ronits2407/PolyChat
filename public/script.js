//======= backend API calling functions==============
const prompt = document.querySelector("#prompt-text");
const modelSelect = document.querySelector("#model-select-drop-down");
const response_div = document.querySelector(".response");
const conversation = document.querySelector("#conversation");
const send_button = document.querySelector(".send");
const API_BASE_URL = "http://localhost:5000/api";
const params = new URLSearchParams(window.location.search);

async function handleChat(message, model, chatId = null) {
  try {
    const response = await fetch(`${API_BASE_URL}/chat`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        message: message,
        model: model,
        chatId: chatId,
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error calling handleChat API:", error);
    throw error;
  }
}
//===================

//========= Responsive UI components

//--------scrolling
function scrollToBottom() {
  conversation.scrollTo({
    top: conversation.scrollHeight,
    behavior: "smooth",
  });
}

//------------sidepane toggle
const panel = document.querySelector("#panel");
const sidepanetoggle = document.querySelector("#chat-history-button");

sidepanetoggle.addEventListener("click", () => {
  if (panel.style.display == "flex") {
    panel.style.display = "none";
  } else {
    panel.style.display = "flex";
  }
});

window.addEventListener("resize", () => {
  if (window.innerWidth < 768) {
    panel.style.display = "none";
  } else {
    panel.style.display = "flex";
  }
});
//=====================

//============== chat handlers
let questionId = 2;

async function getanswer(promptInfo) {
  const model = promptInfo.model;
  const message = promptInfo.message;
  const question_ID = promptInfo.ID;

  if (!message || !model || !question_ID) {
    throw new Error("Parameters of the promptInfo are empty");
  }

  prompt.innerHTML = "";
  let response_curr = response_div.cloneNode(true);
  response_curr.style.display = "flex";
  response_curr.classList.remove("question-1");
  response_curr.classList.add(`question-${question_ID}`);
  response_curr.querySelector(".question").textContent = message;
  const answer_content = response_curr.querySelector(".answer");
  answer_content.innerHTML = "";

  let temp = response_curr.cloneNode(true);
  response_curr.querySelector(".response-info").remove();
  response_curr.querySelector(".related-questions").remove();

  conversation.appendChild(response_curr);
  scrollToBottom();
  try {
    let data = await handleChat(message, model);
    response_curr = document.querySelector(`.question-${question_ID}`);
    temp.querySelector(
      ".model-name"
    ).textContent = `Answer generated by ${model}`;
    temp.querySelector(".answer").innerHTML = marked.parse(data.message);

    response_curr.appendChild(temp.querySelector(".response-info"));
    scrollToBottom();
    // handle the realated questions thing
    // response_curr.appendChild(temp.childNodes[2]);
    return;
  } catch (error) {
    console.error(error);
    return;
  }
}

// function for getting the contents of a specific chat
async function getChatById(ID) {
  try {
    let response = await fetch(`${API_BASE_URL}/conversations/${ID}`, {
      method: "GET",
    });

    if (!response.ok) {
      throw new Error(`Response status retured an error : ${response.status}`);
    }
    const data = await response.json();

    return data;
  } catch (error) {
    throw new Error("Could not get the conversation for chatid:" + ID);
  }
}

// function for displaying the chat in the chatarea
function displayChat(_conversation) {
  for (const [index, message] of _conversation.messages.entries()) {
    if (message.role == "user") {
      let answer = _conversation.messages[index + 1];
      if (!answer) {
        continue;
      }
      let temp = response_div.cloneNode(true);
      temp.style.display = "flex";
      temp.querySelector(".question").textContent = message.content;
      temp.querySelector(
        ".model-name"
      ).textContent = `Answer generated by ${answer.model}`;
      temp.querySelector(".answer").innerHTML = answer.content;

      conversation.appendChild(temp);
      scrollToBottom();
    }
  }
}

// load the first chat when the page loads
if (params.get("model") && params.get("query")) {
  getanswer({
    model: params.get("model"),
    message: params.get("query"),
    ID: questionId,
  });
  modelSelect.value = params.get("model");
  window.history.replaceState({}, "", window.location.pathname);
  questionId++;
} else if (params.get("chatid")) {
  let chatid = params.get("chatid");
  window.history.replaceState({}, "", window.location.pathname);
  async function temp() {
    try {
      const chatData = await getChatById(chatid);
      displayChat(chatData);
    } catch (error) {
      throw new Error("Could not display chat in the chatarea due to " + error);
    }
  }

  temp();
} else {
  window.location.replace(`${window.location.origin}`);
}

send_button.addEventListener("click", async () => {
  const query = prompt.value;
  const model = modelSelect.value;

  getanswer({
    model,
    message: query,
    ID: questionId,
  });

  questionId++;
});

prompt.addEventListener("keydown", async (evt) => {
  const query = prompt.value;
  const model = modelSelect.value;

  if (evt.key != "Enter") {
    return;
  }

  getanswer({
    model,
    message: query,
    ID: questionId,
  });

  questionId++;
});

// for screen 2

//=====================copy to clipboard logic
async function copyToClip(id) {
  const copid = document
    .querySelector(`.question-${id}`)
    .querySelector(".answer");
  try {
    await navigator.clipboard.writeText(copid.textContent);
  } catch (error) {
    console.error("Failed to copy");
  }
}

const copyButtons = document.querySelectorAll(".copy");

copyButtons.forEach((button) => {
  button.addEventListener("click", async (info) => {
    let grandparent = info.target.parentElement.parentElement;
    let grand_grandparent = grandparent.parentElement.parentElement;
    let question = grand_grandparent.parentElement;

    let id = Number(question.classList[1].substring(9));
    await copyToClip(id);
  });
});

//=============== New Chat button
const newchatbutton = document.querySelector("#newchat");
const recentChatList = document.querySelector(".recentChatList");
const templateChat = document.querySelector(".recentChat");

newchatbutton.addEventListener("click", () => {
  let newchat = templateChat.cloneNode(true);
  newchat.style.display = "flex";
  let firstquestion = document.querySelectorAll(".response");
  if (firstquestion.length == 1) {
    window.location.href = `${window.location.origin}/`;
    return;
  }

  newchat.querySelector("a").textContent =
    firstquestion[1].querySelector(".question").textContent;
  recentChatList.prepend(newchat);
  // window.location.href = `${window.location.origin}/`
});

// =============== Load the titles of all chats ==
const chatTitleTemplate = document.querySelector(".recentChat");
const ChatListDiv = document.querySelector(".recentChatList");

async function getTitles() {
  try {
    const response = await fetch(`${API_BASE_URL}/conversations`, {
      method: "GET",
    });

    if (!response.ok) {
      throw new Error(`Failed to get chat titles: ${response.status}`);
    }
    const data = await response.json();

    for (const conversation of data) {
      let temp = chatTitleTemplate.cloneNode(true);

      temp.style.display = "flex";
      let link = temp.querySelector("a");
      link.id = conversation._id;
      link.textContent = conversation.title;

      ChatListDiv.prepend(temp);
    }
  } catch (error) {
    console.error("Error calling handleChat API:", error);
    throw error;
  }
}

getTitles();

// =============== set such that when chatlist are clicked the displaychat gets called
recentChatList.querySelectorAll(".recentChat").forEach((recentChat) => {
  recentChat.querySelector("a").addEventListener("click", async (evt) => {
    const chatData = await getChatById(evt.target.id); // wait for the data
    displayChat(chatData);
  });
});
